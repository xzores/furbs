package wrappers;

import "core:mem"
import "core:runtime"
import "core:os"
import "core:strconv"
import "core:reflect"
import "core:strings"
import "core:fmt"
import "core:math"

import gl "OpenGL"
import utils "../../utils"

_ :: gl.GLenum;

RENDER_DEBUG	:: #config(DEBUG_RENDER, ODIN_DEBUG)
RECORD_DEBUG 	:: #config(DEBUG_RECORD, ODIN_DEBUG)

//TODO glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_FALSE);

/////////// Opengl handles ///////////
Shader_program_id :: distinct u32;

Texture_id :: distinct u32;

Attribute_id :: distinct i32;
Uniform_id :: distinct i32;

Vao_id :: distinct i32;
Fbo_id :: distinct u32;
Rbo_id :: distinct u32;
Buffer_id :: distinct i32; //used for generic buffers, like VBO's and EBO's

Fence_id :: distinct u32;

MAX_COLOR_ATTACH :: 8; //If we use opengl 3.0 we can only have 4 color attachements here.

Uniform_type :: enum u64 {
	invalid 		= 0,
	float 			= gl.FLOAT,
	vec2 			= gl.FLOAT_VEC2,
	vec3 			= gl.FLOAT_VEC3,
	vec4 			= gl.FLOAT_VEC4,
	int 			= gl.INT,
	ivec2 			= gl.INT_VEC2,
	ivec3 			= gl.INT_VEC3,
	ivec4 			= gl.INT_VEC4,
	uint 			= gl.UNSIGNED_INT,
	uvec2 			= gl.UNSIGNED_INT_VEC2,
	uvec3 			= gl.UNSIGNED_INT_VEC3,
	uvec4 			= gl.UNSIGNED_INT_VEC4,
	bool 			= gl.BOOL,
	mat2 			= gl.FLOAT_MAT2,
	mat3 			= gl.FLOAT_MAT3,
	mat4 			= gl.FLOAT_MAT4,
	sampler_1d 		= gl.SAMPLER_1D,
	sampler_2d 		= gl.SAMPLER_2D,
	sampler_3d 		= gl.SAMPLER_3D,
	sampler_cube	= gl.SAMPLER_CUBE,
	isampler_1d 	= gl.INT_SAMPLER_1D,
	isampler_2d 	= gl.INT_SAMPLER_2D,
	isampler_3d 	= gl.INT_SAMPLER_3D,
	isampler_cube 	= gl.INT_SAMPLER_CUBE,
	isampler_buffer = gl.INT_SAMPLER_BUFFER,
	//TODO should we support more? : https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetActiveUniform.xhtml
}

Attribute_type :: enum u32 {
	invalid 		= 0,
	float 			= gl.FLOAT,
	vec2 			= gl.FLOAT_VEC2,
	vec3 			= gl.FLOAT_VEC3,
	vec4 			= gl.FLOAT_VEC4,
	int 			= gl.INT,
	ivec2 			= gl.INT_VEC2,
	ivec3 			= gl.INT_VEC3,
	ivec4 			= gl.INT_VEC4,
	uint 			= gl.UNSIGNED_INT,
	uvec2 			= gl.UNSIGNED_INT_VEC2,
	uvec3 			= gl.UNSIGNED_INT_VEC3,
	uvec4 			= gl.UNSIGNED_INT_VEC4,
	//mat2 			= gl.FLOAT_MAT2,
	//mat3 			= gl.FLOAT_MAT3,
	//mat4 			= gl.FLOAT_MAT4,
}

Attribute_primary_type :: enum u32 {
	invalid 		= 0,
	float 			= gl.FLOAT,
	int 			= gl.INT,
	uint 			= gl.UNSIGNED_INT,
}

Uniform_info :: struct {
	location : Uniform_id,
	uniform_type : Uniform_type,
	array_size : i32,
}

Attribute_info :: struct {
	location : Attribute_id,
	attribute_type : Attribute_type,
}

Attribute_info_ex :: struct {
	offset : uintptr,
	stride : i32,
	normalized : bool,
	using _ : Attribute_info,
}

odin_type_to_attribute_type :: proc (odin_type : typeid) -> Attribute_type {
	switch odin_type {
		case f32:
			return .float;
		case [2]f32:
			return .vec2;
		case [3]f32:
			return .vec3;
		case [4]f32:
			return .vec4;
		case i32:
			return .int; 
		case [2]i32:
			return .ivec2; 
		case [3]i32:
			return .ivec3; 
		case [4]i32:
			return .ivec4;
		case u32:
			return .uint;
		case [2]u32:
			return .uint;
		case [3]u32:
			return .uint;
		case [4]u32:
			return .uint;
		case:
			return .invalid;
	}

	return .invalid;
}

//return the "entries" or number of dimensions. numbers are between 0 and 4.
get_attribute_type_dimensions :: proc (at : Attribute_type) -> int {
	switch at {
		case .invalid:
			return 0;
		case .float, .int, .uint:
			return 1;
		case .vec2, .ivec2, .uvec2:
			return 2; 
		case .vec3, .ivec3, .uvec3:
			return 3;
		case .vec4, .ivec4, .uvec4:
			return 4;
	}

	return 0;
}

get_attribute_primary_type :: proc (at : Attribute_type) -> Attribute_primary_type {
	switch at {
		case .invalid:
			return .invalid;
		case .float, .vec2, .vec3, .vec4: 
			return .float;
		case .int, .ivec2, .ivec3, .ivec4:
			return .int; 
		case .uint, .uvec2, .uvec3, .uvec4:
			return .uint;
	}

	return .invalid;
}

get_attribute_primary_byte_len :: proc (at : Attribute_primary_type) -> int {
	switch at {
		case .invalid:
			return 0;
		case .float: 
			return size_of(f32);
		case .int:
			return size_of(i32); 
		case .uint:
			return size_of(u32); 
	}

	return 0;
}

Cull_method :: enum u32 {
	no_cull,
	front_cull = gl.FRONT,
	back_cull = gl.BACK,
}

Polygon_mode :: enum u32 {
	points 			= gl.POINTS,
	lines 			= gl.LINES,
	fill 			= gl.FILL,
}

Primitive :: enum u32 {
	points 			= gl.POINTS,
	line_strip 		= gl.LINE_STRIP,
	lines 			= gl.LINES,
	triangle_strip 	= gl.TRIANGLE_STRIP,
	triangles 		= gl.TRIANGLES,
}

//TODO how to make proper blend functions?
/*
Blend_factor :: enum {
	zero,
	one,
	alpha,
	one_minus_alpha,
}

//TODO blend mode is 2 blend factors, and they should
//TODO make a per channel blend mode, (4x2 blend mode)

Blend_mode :: union {
	[2]Blend_factor,
	[4][2]Blend_factor,
}
*/
//TODO how to make proper blend functions?

Blend_mode :: enum {
	no_blend,
	blend,
}

/////// Resources ///////

//this is just a hint, version of GL can change underlying behavior.
Transfer_behavior :: enum u32 {
	sync,
	async,
	persistent, //will fallback to async if not advaliable
}

Resource_usage :: enum u32 {
	//gl.STREAM_DRAW,
	//gl.STREAM_READ,
	//gl.STREAM_COPY,
	static_write = gl.STATIC_DRAW,
	static_read =	gl.STATIC_READ,
	//static_copy? = gl.STATIC_COPY, //TODO
	dynamic_write = gl.DYNAMIC_DRAW,
	dynamic_read = gl.DYNAMIC_READ,
	//dynamic_copy? = gl.DYNAMIC_COPY, //TODO
}

Buffer_type :: enum u32 {
	array_buffer = gl.ARRAY_BUFFER,								//Version GL 1.5	//Used as attribute data, yeah pretty normal stuff
	//would anyone use this? = gl.ATOMIC_COUNTER_BUFFER,		//Version GL 3.1 	//I don't know when I would use this, seems like a way to slow down shaders
	//dispatch_indirect_buffer= gl.DISPATCH_INDIRECT_BUFFER,	//Version GL 4.3	//something with computes shaders, we will likely not use this, We wont support compute shaders... (use fraqment or vertex)
	draw_indirect_buffer = gl.DRAW_INDIRECT_BUFFER,				//Version GL 4.0	//Used for GL_MULTI_DRAW_INDIRECT, we will use this when advaliable
	element_array_buffer = gl.ELEMENT_ARRAY_BUFFER,				//Version GL 1.5	//Used to hold indicies... yeah big surprise
	pixel_pack_buffer = gl.PIXEL_PACK_BUFFER,					//Version GL 2.1	//Used to download (from GPU to CPU) pixels, it is optimized for this.
	pixel_unpack_buffer = gl.PIXEL_UNPACK_BUFFER,				//Version GL 2.1	//Used to upload (from CPU to GPU) pixels, it is optimized for this.
	//??? = gl.QUERY_BUFFER,									//Version GL 4.4 	//???
	shader_storage_buffer = gl.SHADER_STORAGE_BUFFER,			//Version GL 4.3 	//We will not use this (too new), it allows fast read/writes from the shader.
	texture_buffer = gl.TEXTURE_BUFFER,							//Version GL 3.1 	//Use to store access large amount of memory from the shader (it is not a real texture, it is a hacky way to access data).
	transform_feedback_buffer = gl.TRANSFORM_FEEDBACK_BUFFER,	//Version GL 3.0 	//This is a way to process data in a vertex shader without rasterizing or fragment shader. Use for partical systems and such.
	uniform_buffer = gl.UNIFORM_BUFFER,							//Version GL 3.1	//We will not use this...
}

Resource_desc :: struct {
	behavior : Transfer_behavior,
	usage : Resource_usage,
	buffer_type : Buffer_type,
	bytes_count : int,
}

Resource :: struct {

	buffer 	: Buffer_id, //Vertex buffer or somthing
	upload_fence 	: Fence_id,
	using_fence 	: Fence_id,
	data 	: []u8,

	client_access_range : Maybe([2]int),

	using desc : Resource_desc,
}

Index_buffer_type :: enum u32 {
	no_index_buffer,
	unsigned_short = gl.UNSIGNED_SHORT,
	unsigned_int = gl.UNSIGNED_INT,
}

GL_version :: enum {
	invalid = 0,
	opengl_3_0,
	opengl_3_1,
	opengl_3_2,
	opengl_3_3,
	opengl_4_0,
	opengl_4_1,
	opengl_4_2,
	opengl_4_3,
	opengl_4_4,
	opengl_4_5,
	opengl_4_6,
}

/////////// Helper funcs ///////////

@(require_results)
get_major :: proc(version : GL_version) -> int {
	
	if version >= .opengl_4_0 {
		return 4;
	}
	
	if version >= .opengl_3_0 {
		return 3;
	}

	return 0;
} 

@(require_results)
get_minor :: proc(version : GL_version) -> int {
	
	switch version {
		case .opengl_3_0, .opengl_4_0:
			return 0;
		case .opengl_3_1, .opengl_4_1:
			return 1;
		case .opengl_3_2, .opengl_4_2:
			return 2;
		case .opengl_3_3, .opengl_4_3:
			return 3;
		case .opengl_4_4:
			return 4;
		case .opengl_4_5:
			return 5;
		case .opengl_4_6:
			return 6;
		case .invalid:
			return 0;
		case:
			return 0;
	}

	return 0;
}

/////////// Debugging ///////////

Source_Code_Location :: runtime.Source_Code_Location;

Id :: union {
	Shader_program_id,
	Buffer_id,
	Vao_id,
	Fbo_id,
	Rbo_id
}

when RENDER_DEBUG {

	GL_debug_state :: struct {
		programs 	: map[]int,
		buffers 	: map[Source_Code_Location]int,
		vaos 		: map[Source_Code_Location]int,
		fbos 		: map[Source_Code_Location]int,
		rbos 		: map[Source_Code_Location]int,
	}

	debug_state : GL_debug_state;

	/* 
	live_shaders : map[Shader_program_id]struct{},
	live_framebuffers : map[Fbo_id]struct{},
	live_buffers : map[Buffer_id]struct{},
	live_vaos : map[Vao_id]struct{},
	*/
}

gpu_state : GL_state;
cpu_state : GL_state;
info : GL_info;			//fecthed in the begining and can be read from to get system information.

GL_state :: struct {

	gl_version : GL_version,

	bound_shader : Shader_program_id,
	
	bound_target : Fbo_id,
	
	bound_vbo : Vao_id,

	bound_vao : Buffer_id,
	bound_ebo : Buffer_id,

	blend_mode : Blend_mode,
	depth_write : bool,
	depth_test : bool,
	polygon_mode : Polygon_mode,
	culling : Cull_method,
}

GL_info :: struct {
	MAX_SAMPLES : i32,
	MAX_INTEGER_SAMPLES : i32,
	MAX_VERTEX_ATTRIB_BINDINGS : i32,
	MAX_VERTEX_ATTRIBS : i32,
	MAX_VERTEX_ATTRIB_STRIDE : i32,
	MAX_VERTEX_ATTRIB_RELATIVE_OFFSET : i32,
	MAX_TEXTURE_SIZE : i32,
	MAX_3D_TEXTURE_SIZE : i32,
	MAX_CUBE_MAP_TEXTURE_SIZE : i32,
	MAX_TEXTURE_UNITS : i32,
	MAX_TEXTURE_IMAGE_UNITS : i32,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS : i32,
	MAX_GEOMETRY_TEXTURE_IMAGE_UNITS : i32,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS : i32,
	MAX_TEXTURE_COORDS : i32,
	MAX_ARRAY_TEXTURE_LAYERS : i32,
}

debug_callback : gl.debug_proc_t : proc "c" (source: gl.GLenum, type: gl.GLenum, id: gl.GLuint, severity: gl.GLenum, length: gl.GLsizei, message: cstring, user_param : rawptr) {
	context = runtime.default_context();
    // Print or handle the debug message here
    fmt.printf("OpenGL Debug Message: %.*s\n", length, message);
}

init :: proc() {
	when RECORD_DEBUG {
		setup_call_recorder();
		gl.capture_gl_callback = record_call;
		gl.capture_error_callback = record_err;
		
		if cpu_state.gl_version >= .opengl_4_3 {
			// Enable debug messages
			//fmt.printf("Enable : %v", gl.Enable);
			gl.Enable(.DEBUG_OUTPUT);
			gl.Enable(.DEBUG_OUTPUT_SYNCHRONOUS);

			// Set up debug callback function
			//gl.DebugMessageCallback(debug_callback, nil);

			// Optionally, specify debug message control
			//gl.DebugMessageControl(.DONT_CARE, .DONT_CARE, .DONT_CARE, 0, nil, true);
			//fmt.printf("Subscribed to OpenGL debug messages\n");
		}
	}

	info = fetch_gl_info();
	fmt.printf("System info : %#v\n", info);
}

destroy :: proc(loc := #caller_location) {
	when RECORD_DEBUG {
		destroy_call_recorder();
	}
	when RENDER_DEBUG {
		leaks := 0;

		for field in reflect.struct_fields_zipped(GL_debug_state) {
			
			s := cast(^map[Source_Code_Location]int)(cast(uintptr)&debug_state + field.offset);

			for loc, cnt in s {
				if cnt != 0 {
					fmt.printf("Leak detected! %i allocations where made at location : %v\n", cnt, loc);
					leaks += cnt;
				}
			}

		}
		
		fmt.assertf(leaks == 0, "%v OpenGL objects has not been destroyed\n", leaks, loc = loc);
	}
}

/////////// recording ///////////

Error_Enum :: gl.Error_Enum;

when RECORD_DEBUG {
	record_output : os.Handle;
}

setup_call_recorder :: proc (filename : string = "gl_calls.txt") {
	when RECORD_DEBUG {
		err : os.Errno;
		record_output, err = os.open(filename, os.O_CREATE|os.O_TRUNC);
		if err != 0 {
			panic("Could not open record file");
		}
		else {
			fmt.printf("recording calles to %v\n", filename);
		}
	}
}

destroy_call_recorder :: proc () {
	when RECORD_DEBUG {
		err := os.close(record_output);
		if err != 0 {
			fmt.panicf("Could not close record file, %v", err);
		}
	}
}

record_call :: proc(from_loc : runtime.Source_Code_Location, ret_val : any, args : []any, loc : runtime.Source_Code_Location) {
	when RECORD_DEBUG {
		os.write_string(record_output, fmt.tprintf("gl%s(", loc.procedure));

		for arg, i in args {
			
			if i > 0 { os.write_string(record_output, ", ") }
			
			if v, ok := arg.(gl.GLenum); ok {
				os.write_string(record_output, fmt.tprintf("GL_%v", v));
			} 
			else if v, ok := arg.(gl.GLbitfield); ok {
				os.write_string(record_output, fmt.tprintf("GL_%v", v));
			} 
			else if v, ok := arg.(u32); ok {
				os.write_string(record_output, fmt.tprintf("%v", v));
			}
			else if v, ok := arg.(i32); ok {
				os.write_string(record_output, fmt.tprintf("%v", v));
			}
			else if v, ok := arg.(f32); ok {
				os.write_string(record_output, fmt.tprintf("%v", v));
			}
			else {
				os.write_string(record_output, fmt.tprintf("(%v)%v", arg.id, arg));
			}
		}

		if ret_val != nil {
			os.write_string(record_output, fmt.tprintf(") -> %v", ret_val));
		}
		else {
			os.write_string(record_output, ")");
		}

		os.write_string(record_output, "\n");
		
		os.flush(record_output);
	}
}

record_err :: proc(from_loc: runtime.Source_Code_Location, err_val: any, err : Error_Enum, args : []any, loc : runtime.Source_Code_Location) {

	fmt.printf("glGetError() returned GL_%v\n", err)
	fmt.printf("	from: gl%s(", loc.procedure);
	for arg, i in args {
		if i != 0 {
			fmt.printf(", ");
		}
		fmt.printf("%v", arg);
	}
	fmt.printf(")\n");

	// add location
	//fmt.printf("	in:   %s(%d:%d)\n", from_loc.file_path, from_loc.line, from_loc.column)

	if cpu_state.gl_version >= .opengl_4_3 {
		
		mes_cnt : gl.GLint;
		gl.GetIntegerv(.DEBUG_LOGGED_MESSAGES, &mes_cnt)
		
		for mes_cnt != 0 {
			
			l : gl.GLint;
			gl.GetIntegerv(.DEBUG_NEXT_LOGGED_MESSAGE_LENGTH, &l);
			
			err_str := make([]u8, l+2);

			message_sources : []gl.GLenum = {
				.DEBUG_SOURCE_API,
				.DEBUG_SOURCE_WINDOW_SYSTEM,
				.DEBUG_SOURCE_SHADER_COMPILER,
				.DEBUG_SOURCE_THIRD_PARTY,
				.DEBUG_SOURCE_APPLICATION,
				.DEBUG_SOURCE_OTHER,
			}

			message_types : []gl.GLenum = {
				.DEBUG_TYPE_ERROR,
				.DEBUG_TYPE_DEPRECATED_BEHAVIOR,
				.DEBUG_TYPE_UNDEFINED_BEHAVIOR,
				.DEBUG_TYPE_PORTABILITY,
				//.DEBUG_TYPE_PERFORMANCE,
				//.DEBUG_TYPE_MARKER,
				//.DEBUG_TYPE_PUSH_GROUP,
				//.DEBUG_TYPE_POP_GROUP,
				//.DEBUG_TYPE_OTHER,
			}
			
			message_severities : []gl.GLenum = {
				.DEBUG_SEVERITY_HIGH,
				.DEBUG_SEVERITY_MEDIUM,
				.DEBUG_SEVERITY_LOW,
				.DEBUG_SEVERITY_NOTIFICATION,
			}

			gl.GetDebugMessageLog(1, l, raw_data(message_sources[:]), raw_data(message_types[:]), nil, raw_data(message_severities[:]), &l, raw_data(err_str));
			//(count : GLuint, bufSize : GLsizei, sources : ^GLenum, types : ^GLenum, ids : ^GLuint, severities : ^GLenum, lengths : ^GLsizei, messageLog : GLoutstring

			fmt.printf("	recive debug message : %v\n", string(err_str));
			gl.GetIntegerv(.DEBUG_LOGGED_MESSAGES, &mes_cnt)
		}
	}

	panic("Caught opengl error!", from_loc);
}

/////////// Getters/GLFW  ///////////

@(require_results)
fetch_gl_info :: proc () -> (info : GL_info) {
	
	fields := reflect.struct_fields_zipped(GL_info);

	for field in fields {
		to_fetch, ok := reflect.enum_from_name(gl.GLenum, field.name);
		field_pointer : rawptr = cast(rawptr)(cast(uintptr)&info + field.offset);
		gl.GetIntegerv(to_fetch, cast(^i32) field_pointer);
	}

	return;
}

@(require_results)
get_version :: proc() -> GL_version {
	
	v := gl.GetString(auto_cast gl.VERSION); //TODO: This does not need to be deleted i think?
	version := strings.clone_from(v);

	Major : int = strconv.atoi(version[0:1]);
	Minor : int = strconv.atoi(version[2:3]);

	if Major < 3 {
		panic("A higher version of opengl is required");
	}
	
	if Major == 3 && Minor == 0 {
		return .opengl_3_0;
	}
	else if Major == 3 && Minor == 1 {
		return .opengl_3_1;
	}
	else if Major == 3 && Minor == 2 {
		return .opengl_3_2;
	}
	else if Major == 3 && Minor == 3 {
		return .opengl_3_3;
	}
	else if Major == 3 {
		return .opengl_3_3; //if 3.4 or 3.5 releases at some point.
	}
	
	if Major == 4 && Minor == 0 {
		return .opengl_4_0;
	}
	else if Major == 4 && Minor == 1 {
		return .opengl_4_1;
	}
	else if Major == 4 && Minor == 2 {
		return .opengl_4_2;
	}
	else if Major == 4 && Minor == 3 {
		return .opengl_4_3;
	}
	else if Major == 4 && Minor == 4 {
		return .opengl_4_4;
	}
	else if Major == 4 && Minor == 5 {
		return .opengl_4_5;
	}
	else if Major == 4 && Minor == 6 {
		return .opengl_4_6;
	}
	else if  Major == 4 {
		return .opengl_4_6; //if 4.7 or 4.8 releases at some point.
	}

	if Major > 4 {
		return .opengl_4_6;
	}

	unreachable();
}

load_up_to :: proc (version : GL_version, set_proc : proc(p: rawptr, name: cstring)) {

	cpu_state.gl_version = version;
	gpu_state.gl_version = version;

	major : int = get_major(version);
	minor : int = get_minor(version);
	
	gl.load_up_to(major, minor, set_proc);
}

//////////////////////////////////////////// Functions ////////////////////////////////////////////

gen_vertex_arrays :: proc(vaos : []Vao_id, loc := #caller_location) {

	
	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateVertexArrays(auto_cast len(vaos), cast([^]u32) raw_data(vaos));
	}
	else {
		gl.GenVertexArrays(auto_cast len(vaos), cast([^]u32) raw_data(vaos));
	}

	when RENDER_DEBUG {
		debug_state.vaos[loc] += len(vaos);
	}
}

gen_vertex_array :: proc(loc := #caller_location) -> Vao_id {
	
	when RENDER_DEBUG {
		debug_state.vaos[loc] += 1;
	}

	vao : u32;

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateVertexArrays(1, cast([^]u32) &vao);
	}
	else {
		gl.GenVertexArrays(1, cast([^]u32) &vao);
	}

	return auto_cast vao;
}


//TODO should we even use Buffer_type? we keep it, it is easier to remove then add.
gen_buffers :: proc(_ : Buffer_type, buffers : []Buffer_id, loc := #caller_location) {

	when RENDER_DEBUG {
		debug_state.buffers[loc] += len(buffers);
	}

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateBuffers(auto_cast len(buffers), cast([^]u32) raw_data(buffers));
	}
	else {
		gl.GenBuffers(auto_cast len(buffers), cast([^]u32) raw_data(buffers));
	}
}

gen_buffer :: proc(_ : Buffer_type, loc := #caller_location) -> (buf : Buffer_id) {

	when RENDER_DEBUG {
		debug_state.buffers[loc] += 1;
	}

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateBuffers(1, auto_cast &buf);
	}
	else {
		gl.GenBuffers(1, auto_cast &buf);
	}

	return;
}

delete_buffers :: proc(buffers : []Buffer_id, loc := #caller_location) {

	when RENDER_DEBUG {
		debug_state.buffers[loc] -= len(buffers);
	}

	gl.DeleteBuffers(auto_cast len(buffers), cast([^]u32) raw_data(buffers));
}

delete_buffer :: proc(buffer : Buffer_id, loc := #caller_location) {
	
	when RENDER_DEBUG {
		debug_state.buffers[loc] -= 1;
	}
	
	buffer := buffer;
	gl.DeleteBuffers(1, auto_cast &buffer);
}

@(deprecated="TODO use gl_buffer_storge instead of buffer data where appliciable, then we should also make a resize function")
buffer_data :: proc(buffer : Buffer_id, target : Buffer_type, size : int, data : rawptr, usage : Resource_usage) {
	if cpu_state.gl_version >= .opengl_4_5 {
		gl.NamedBufferData(auto_cast buffer, size, data, auto_cast usage);
	}
	else {
		gl.BindBuffer(auto_cast target, auto_cast buffer);
		gl.BufferData(auto_cast target, size, data, auto_cast usage);
		gl.BindBuffer(auto_cast target, 0); //maybe only unbind in DEBUG
	}
}

buffer_sub_data :: proc (buffer : Buffer_id, target : Buffer_type, #any_int offset_bytes : int, data : []u8) {
	if cpu_state.gl_version >= .opengl_4_5 {
		gl.NamedBufferSubData(auto_cast buffer, offset_bytes, len(data), raw_data(data));
	}
	else {
		gl.BindBuffer(auto_cast target, auto_cast buffer);
		gl.BufferSubData(auto_cast target, offset_bytes, len(data), raw_data(data));
		gl.BindBuffer(auto_cast target, 0); //maybe only unbind in DEBUG
	}
}

Map_buffer_usage :: enum u32 {
	read_only = gl.READ_ONLY,
	write_only = gl.WRITE_ONLY,
	read_write = gl.READ_WRITE,
}

map_buffer :: proc (buffer : Buffer_id, buffer_type : Buffer_type, usage : Map_buffer_usage) -> (p : rawptr) {
	
	flags : u32 = cast(u32)usage | gl.MAP_UNSYNCHRONIZED_BIT;

	if cpu_state.gl_version >= .opengl_4_5 {
		p = gl.MapNamedBuffer(auto_cast buffer, auto_cast flags); //TODO do buffer range???
	}
	else {
		gl.BindBuffer(auto_cast buffer_type, auto_cast buffer);
		p = gl.MapBuffer(auto_cast buffer_type, auto_cast flags);
		gl.BindBuffer(auto_cast buffer_type, 0);
	}

	return;
}

unmap_buffer :: proc (buffer : Buffer_id, buffer_type : Buffer_type) {

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.UnmapNamedBuffer(auto_cast buffer);
	}
	else {
		gl.BindBuffer(auto_cast buffer_type, auto_cast buffer);
		gl.UnmapBuffer(auto_cast buffer_type);
		gl.BindBuffer(auto_cast buffer_type, 0);
	}
}

//TODO this assumes only one buffer per VAO
associate_buffer_with_vao :: proc (vao : Vao_id, buffer : Buffer_id, attributes : []Attribute_info_ex, loc := #caller_location) {

	gl.BindVertexArray(auto_cast vao);
	gl.BindBuffer(.ARRAY_BUFFER, auto_cast buffer);
	
	for attrib, i in attributes {
		//fmt.printf("setting up VertexAttribPointer : %v, %v, %v, %v, %v, %v\n", attrib.location, get_attribute_type_dimensions(attrib.attribute_type), get_attribute_primary_type(attrib.attribute_type), attrib.normalized, attrib.stride, attrib.offset);
		gl.VertexAttribPointer(auto_cast attrib.location, auto_cast get_attribute_type_dimensions(attrib.attribute_type), auto_cast get_attribute_primary_type(attrib.attribute_type), attrib.normalized, attrib.stride, attrib.offset);
		gl.EnableVertexAttribArray(auto_cast attrib.location);
		//VertexAttribPointer      :: proc "c" (index: u32, size: i32, type: u32, normalized: bool, stride: i32, pointer: uintptr)
	}

	gl.BindBuffer(.ARRAY_BUFFER, 0);
	gl.BindVertexArray(0);
}

draw_arrays :: proc (vao : Vao_id, primitive : Primitive, #any_int first, count : i32) {
	gl.BindVertexArray(auto_cast vao);
    gl.DrawArrays(auto_cast primitive, first, count);
   	gl.BindVertexArray(0);
}

/////////// pipeline ///////////

set_blend_mode :: proc(blend_mode : Blend_mode) {
	//TODO how to make proper blend functions?

	/* 
	to_gl_factor :: proc (b : Blend_factor, is_src : bool) -> u32 {
		switch b {
			case .one:
				return gl.ONE;
			case .zero:
				return gl.ZERO;
			case .alpha:
				if is_src {
					return gl.SRC_ALPHA;
				}
				else {

				}
		}
	}

	if b, ok := blend_mode.([2]Blend_factor); ok {
		gl.BlendFunc(to_gl_factor(b[0], true), to_gl_factor(b[1], false));
	}
	else {
		panic("TODO");
	}
	*/

	if blend_mode == .blend {
		gl.Enable(.BLEND);
		gl.BlendFunc(.SRC_ALPHA, .ONE_MINUS_SRC_ALPHA);
	}
	else {
		gl.Disable(.BLEND);
		//gl.BlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	}
}

set_depth_write :: proc(depth_write : bool) {

	if depth_write {
		gl.DepthMask(gl.TRUE);
	}
	else {
		gl.DepthMask(gl.FALSE);
	}
}

set_depth_test :: proc(depth_test : bool) {
	
	if depth_test {
		gl.Enable(.DEPTH_TEST);
	}
	else {
		gl.Disable(.DEPTH_TEST);
	}
}

set_polygon_mode :: proc(polygon_mode : Polygon_mode) {
	gl.PolygonMode(.FRONT_AND_BACK, auto_cast polygon_mode);
}

set_culling :: proc(method : Cull_method) {
	if method == .no_cull {
		gl.Disable(.CULL_FACE);
	}
	else {
		gl.Enable(.CULL_FACE);
		gl.CullFace(auto_cast method);
	}
}

set_viewport :: proc(#any_int x, y, width, height : i32) {
	gl.Viewport(x, y, width, height);
}

/////////// shaders ///////////

//return true if error
@(require_results)
load_shader_program :: proc(name : string, vertex_src : string, fragment_src : string, loc := #caller_location) -> (Shader_program_id, bool) {

	compile_shader :: proc (shader_id : u32) -> (err : bool, msg : string) {
		gl.CompileShader(auto_cast shader_id);

		success : i32;
		gl.GetShaderiv(shader_id, .COMPILE_STATUS, &success);

		if success == 0 {
			log_length  : i32;
			gl.GetShaderiv(shader_id, .INFO_LOG_LENGTH, &log_length);

			err_info : []u8 = make([]u8, log_length + 1, allocator = context.temp_allocator);
			gl.GetShaderInfoLog(shader_id, log_length, nil, auto_cast raw_data(err_info));

			return true, string(err_info);
		}

		return false, "";
	}
	
	link_shader_program :: proc (shader_id : u32) -> (err : string) {
		gl.LinkProgram(shader_id);
		
		success : i32;
		
		gl.GetProgramiv(auto_cast shader_id, .LINK_STATUS, &success);

		if success == 0 {
			log_length  : i32;
			gl.GetProgramiv(shader_id, .INFO_LOG_LENGTH, &log_length);

			err_info : []u8 = make_slice([]u8, log_length + 1, allocator = context.temp_allocator);
			gl.GetProgramInfoLog(shader_id, log_length, nil, auto_cast raw_data(err_info));

			return {};
		}

		return {};
	}

	shader_id_vertex := gl.CreateShader(.VERTEX_SHADER);
	shader_id_fragment := gl.CreateShader(.FRAGMENT_SHADER);

	fmt.printf("Sending the vertex shader code to openGL : \n%s\n", vertex_src);
	shader_sources_vertex : [1]cstring = { strings.clone_to_cstring(vertex_src, allocator = context.temp_allocator) }
	gl.ShaderSource(shader_id_vertex, 1, auto_cast &shader_sources_vertex, nil);
	
	fmt.printf("Sending the fragment shader code to openGL : \n%s\n", fragment_src);
	shader_sources_fragment : [1]cstring = { strings.clone_to_cstring(fragment_src, allocator = context.temp_allocator) }
	gl.ShaderSource(shader_id_fragment, 1, auto_cast &shader_sources_fragment, nil);

	if err, msg := compile_shader(auto_cast shader_id_vertex); err {
		fmt.printf("Failed to compile vertex shader %v, ERROR : '%s'\n", name, msg);
		return 0, true;
	}

	if err, msg := compile_shader(auto_cast shader_id_fragment); err {
		fmt.printf("Failed to compile fragment shader %v, ERROR : '%s'\n", name, msg);
		return 0, true;
	}

	shader_program : Shader_program_id = auto_cast gl.CreateProgram();
	gl.AttachShader(auto_cast shader_program, auto_cast shader_id_vertex);
	gl.AttachShader(auto_cast shader_program, auto_cast shader_id_fragment);
	
	if err := link_shader_program(auto_cast shader_program); err != {} {
		fmt.printf("Failed to link shader program %v, ERROR : %s\n", name, err);
		return 0, true;
	}

	gl.DeleteShader(shader_id_vertex);
	gl.DeleteShader(shader_id_fragment);

	when RENDER_DEBUG {
		debug_state.programs[loc] += 1;
	}

	return shader_program, false;
}

unload_shader_program :: proc(shader : Shader_program_id, loc := #caller_location) {
	
	when RENDER_DEBUG {
		debug_state.programs[loc] -= 1;
	}
	
	gl.DeleteProgram(auto_cast shader);
}

use_program :: proc(id : Shader_program_id) {
	gl.UseProgram(auto_cast id);
}

clear_color :: proc(clear_color : [4]f32) {
	gl.ClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w);
	gl.Clear(.COLOR_BUFFER_BIT);
}

clear_depth :: proc() {
	gl.Clear(.DEPTH_BUFFER_BIT);
}

/////////// Buffer stuff ///////////

@(require_results)
make_resource_parameterized :: proc(bytes_count : int, buffer_type : Buffer_type, resource_usage : Resource_usage, behavior : Transfer_behavior, loc :=#caller_location) -> Resource {
	
	resource_desc : Resource_desc = {
		behavior,
		resource_usage,
		buffer_type,
		bytes_count,
	}


	return make_resource_desc(resource_desc, loc);
}

@(require_results)
make_resource_desc :: proc(desc : Resource_desc, loc := #caller_location) -> Resource {

	resource : Resource;
	resource.desc = desc;
	
	resource.buffer = gen_buffer(resource.buffer_type);
	buffer_data(resource.buffer, resource.buffer_type, resource.bytes_count, nil, resource.usage); 
	
	return resource;
}

make_resource :: proc {make_resource_parameterized, make_resource_desc};


destroy_Resource :: proc(resource : ^Resource) {

	switch resource.behavior {
		case .sync:
			if resource.data != nil {
				delete(resource.data);
			}

		case .async:
			panic("TODO");

		case .persistent:
			if cpu_state.gl_version >= .opengl_4_4 {
				panic("TODO");
			}
			else {
				panic("TODO");
			}
	}
	
	delete_buffer(resource.buffer);
}

//there are the following ways to upload data
	//BufferData/BufferSubData, this is a non-blocking sync upload
	//MapBuffer/MapBufferRange is a non-blocking sync/async upload. It seems the specs says nothing on this and that the implementatio may choose to have it sync and not async.
	//MapBuffer/MapBufferRange with GL_MAP_UNSYNCHRONIZED_BIT

//if range == nil then the entire buffer is returned. Range is {being, end}
@(require_results)
begin_buffer_write :: proc(resource : ^Resource, range : Maybe([2]int) = nil) -> (data : []u8) {
	
	if range != nil {
		panic("TODO");
	}

	switch resource.behavior {
		case .sync:
			//just return the host(furbs) data and let them change it, then when done they commit and buffer_sub_data is called there.
			if len(resource.data) != resource.bytes_count {
				//TODO reallocate
				if resource.data != nil {
					delete(resource.data); //TODO this could be done better
				}
				resource.data = make([]u8, resource.bytes_count)
			}
		
		case .async:
			p := map_buffer(resource.buffer, resource.buffer_type, .write_only);
			assert(p != nil, "No mapped data");
			raw : runtime.Raw_Slice = {data = p, len = resource.bytes_count}
			resource.data = transmute([]u8)raw;
			
		case .persistent:
			if cpu_state.gl_version >= .opengl_4_4 {
				panic("TODO");
			}
			else {
				panic("TODO");
			}
	}

	return resource.data;
}

resize_buffer :: proc () {
	//Here if we are in opengl 4.4 we should use glStorageBuffer and if we do that, then we should delete it and recreate it.
	//otherwise we can use glBufferData and just orphan the old data.
	panic("TODO");
}

//Return false if a unnecessary stall/wait is required if end_buffer_write is called at this time.
//return true if it is a good idea to call end_buffer_write.
@(require_results)
is_end_buffer_write_ready :: proc(resource : Resource) -> bool {
	
	switch resource.behavior {
		case .sync:
			return true;

		case .async:
			panic("todo");

		case .persistent:
			if cpu_state.gl_version >= .opengl_4_4 {
				panic("TODO");
			}
			else {
				panic("TODO");
			}
	}

	unreachable();
}

//after calling this you may not change the buffer data (or even keep a refernce to it)
end_buffer_write :: proc(using resource : ^Resource, loc := #caller_location) {

	switch behavior {
		case .sync:
			begin : int = 0;
			end : int = bytes_count;
			if range, ok := client_access_range.?; ok {
				begin = range[0];
				end = range[1];
			}
			buffer_sub_data(buffer, buffer_type, begin, data[begin:end]); //TODO investigate data[begin:end]

		case .async:
			/*when ???? {
				if is_end_buffer_write_ready(resource^) {
					fmt.printf("Warning: a blocking upload was detected at location %v\n", loc);
				}
			}*/
			unmap_buffer(buffer, buffer_type);

		case .persistent:
			panic("todo")
	}

}

/* 
request_buffer_read :: proc(buffer : Resource, range : Maybe([2]int) = nil) {
	
}

commit_buffer_read :: proc() -> (data : []u8) {

}
*/

gen_render_buffers :: proc (rbos : []Rbo_id, loc := #caller_location) {

	when RENDER_DEBUG {
		debug_state.rbos[loc] += len(rbos);
	}

	// Create renderbuffer objects
	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateRenderbuffers(auto_cast len(rbos), auto_cast raw_data(rbos));
	}
	else {
		gl.GenRenderbuffers(auto_cast len(rbos), auto_cast raw_data(rbos));
	}
} 

@(require_results)
gen_render_buffer :: proc (loc := #caller_location) -> Rbo_id {

	when RENDER_DEBUG {
		debug_state.rbos[loc] += 1;
	}

	// Create renderbuffer object
	buffer : u32;
	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateRenderbuffers(1, &buffer);
	}
	else {
		gl.GenRenderbuffers(1, &buffer);
	}
	return auto_cast buffer;
}

delete_render_buffers :: proc(rbos : []Rbo_id, loc := #caller_location) {
	when RENDER_DEBUG {
		debug_state.rbos[loc] -= len(rbos);
	}

	gl.DeleteRenderbuffers(auto_cast len(rbos), auto_cast raw_data(rbos));
}

delete_render_buffer :: proc(rbo : Rbo_id, loc := #caller_location) {
	when RENDER_DEBUG {
		debug_state.rbos[loc] -= 1;
	}

	rbo := rbo;
	gl.DeleteRenderbuffers(1, auto_cast &rbo);
}

gen_frame_buffer :: proc (loc := #caller_location) -> Fbo_id {

	when RENDER_DEBUG {
		debug_state.fbos[loc] += 1;
	}

	// Create a framebuffer object (FBO)
	framebuffer_id : u32;

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.CreateFramebuffers(1, &framebuffer_id);
	}
	else {
		gl.GenFramebuffers(1, &framebuffer_id);
	}

	return auto_cast framebuffer_id;
}

delete_frame_buffer :: proc(fbo : Fbo_id, loc := #caller_location) {
	when RENDER_DEBUG {
		debug_state.fbos[loc] -= 1;
	}

	fbo := fbo;
	gl.DeleteFramebuffers(1, auto_cast &fbo);
}

Color_format :: enum u32 {
	rgba8 = gl.RGBA8,
	rgba16f = gl.RGBA16F,
	rgba32f = gl.RGBA32F,
	rgb8 = gl.RGB8,
	rgb16f = gl.RGB16F,
	rgb32f = gl.RGB32F,
}

associate_color_render_buffers_with_frame_buffer :: proc(fbo : Fbo_id, render_buffers : []Rbo_id, width, height, samples_hint : i32, start_index : int = 0, color_format : Color_format = .rgba8, loc := #caller_location) -> (samples : i32) {

	assert(len(render_buffers) + start_index <= MAX_COLOR_ATTACH, "you can only have up to 8 color attachments", loc);
	assert(color_format != nil, "color_format is nil", loc);

	samples = math.min(samples_hint, info.MAX_SAMPLES, info.MAX_INTEGER_SAMPLES);
	//fmt.assertf(samples != 0, "something wrong, samples are : %v, %v, %v", samples_hint, info.MAX_SAMPLES, info.MAX_INTEGER_SAMPLES);

	if cpu_state.gl_version >= .opengl_4_5 {
		
		// Create a multisampled renderbuffer object for color attachment
		for i in 0 ..< len(render_buffers) {
			
			if samples == 1 {
				gl.NamedRenderbufferStorage(auto_cast render_buffers[i], auto_cast color_format, width, height);
			}
			else {
				gl.NamedRenderbufferStorageMultisample(auto_cast render_buffers[i], samples, auto_cast color_format, width, height);
			}
			
			gl.NamedFramebufferRenderbuffer(auto_cast fbo, auto_cast (cast(u32)gl.GLenum.COLOR_ATTACHMENT0 + auto_cast (i + start_index)), .RENDERBUFFER, auto_cast render_buffers[i]);
		}
	}
	else {
		
		//TODO move the generation out of this function so we can reuse more code. Have the function be like "attach_frame_buffer_render_attachmetns".
		gl.BindFramebuffer(.FRAMEBUFFER, auto_cast fbo);
		
		// Create a multisampled renderbuffer object for color attachment
		for i in 0 ..< len(render_buffers) {

			gl.BindRenderbuffer(.RENDERBUFFER, auto_cast render_buffers[i]);

			if samples == 1 {
				gl.RenderbufferStorage(.RENDERBUFFER, auto_cast color_format, width, height);
			}
			else {
				gl.RenderbufferStorageMultisample(.RENDERBUFFER, samples, auto_cast color_format, width, height);
			}
			
			gl.FramebufferRenderbuffer(.FRAMEBUFFER, auto_cast (cast(u32)gl.GLenum.COLOR_ATTACHMENT0 + auto_cast (i + start_index)), .RENDERBUFFER, auto_cast render_buffers[i]);
		}

		gl.BindRenderbuffer(.RENDERBUFFER, 0);
		gl.BindFramebuffer(.FRAMEBUFFER, 0);	
	}

	return;
}

Depth_format :: enum u32 {
	depth_component16 = gl.DEPTH_COMPONENT16,
	depth_component24 = gl.DEPTH_COMPONENT24,
	depth_component32 = gl.DEPTH_COMPONENT32,
}

associate_depth_render_buffer_with_frame_buffer :: proc(fbo : Fbo_id, render_buffer : Rbo_id, width, height, samples_hint : i32, depth_format : Depth_format = .depth_component24, loc := #caller_location) -> (samples : i32) {

	assert(depth_format != nil, "color_format is nil", loc);
	
	samples = math.min(samples_hint, info.MAX_SAMPLES, info.MAX_INTEGER_SAMPLES);
	assert(samples != 0, "something wrong");

	if cpu_state.gl_version >= .opengl_4_5 {
		
		if samples == 1 {
			gl.NamedRenderbufferStorage(auto_cast render_buffer, auto_cast depth_format, width, height);
		}
		else {
			gl.NamedRenderbufferStorageMultisample(auto_cast render_buffer, samples, auto_cast depth_format, width, height);
		}

		gl.NamedFramebufferRenderbuffer(auto_cast fbo, .DEPTH_ATTACHMENT, .RENDERBUFFER, auto_cast render_buffer);
		
	}
	else {
		gl.BindFramebuffer(.FRAMEBUFFER, auto_cast fbo);
		gl.BindRenderbuffer(.RENDERBUFFER, auto_cast render_buffer);
		
		if samples == 1 {
			gl.RenderbufferStorage(.RENDERBUFFER, auto_cast depth_format, width, height);
		}
		else {
			gl.RenderbufferStorageMultisample(.RENDERBUFFER, samples, auto_cast depth_format, width, height);
		}
		gl.FramebufferRenderbuffer(.FRAMEBUFFER, .DEPTH_ATTACHMENT, .RENDERBUFFER, auto_cast render_buffer);
		
		gl.BindFramebuffer(.FRAMEBUFFER, 0);
		gl.BindRenderbuffer(.RENDERBUFFER, 0);
	}

	return;
}

//TODO make this return an error instead of crashing
validate_frame_buffer :: proc (fbo : Fbo_id, loc := #caller_location) -> (valid : bool) {
	// Check if framebuffer is complete
	
	status := gl.CheckFramebufferStatus(.FRAMEBUFFER);

	if (status != .FRAMEBUFFER_COMPLETE) {
		
		/* 
		TODO move the the associate functions
		for ca, i in color_attachements {
			if attachment, ok := ca.?; ok {

				attachment_type : gl.GLenum;
				attachemnt_id_enum : gl.GLenum = auto_cast (cast(u32)gl.GLenum.COLOR_ATTACHMENT0 + auto_cast i);
				gl.GetFramebufferAttachmentParameteriv(.FRAMEBUFFER, attachemfvt_id_enum, .FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, auto_cast &attachment_type);

				if (attachment_type == .NONE) {
					fmt.printf("Framebuffer is missing a color attachment %v", i);
				}
				assert(attachment_type == .RENDERBUFFER, "attachment_type is not a renderbuffer!");
			}
		}

		depth_attachment_type : gl.GLenum;
		gl.GetFramebufferAttachmentParameteriv(.FRAMEBUFFER, .DEPTH_ATTACHMENT, .FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, auto_cast &depth_attachment_type);
		if (depth_attachment_type == .NONE) {
			fmt.printf("Framebuffer is missing a depth attachment");
		}
		assert(depth_attachment_type == .RENDERBUFFER, "attachment_type is not a renderbuffer!");
		fmt.panicf("TODO move this. Framebuffer is not complete! Statues : %v", status, loc = loc);
		*/
		return false;
	}

	return true;
}

bind_frame_buffer :: proc(fbo : Fbo_id) {
	gl.BindFramebuffer(.FRAMEBUFFER, auto_cast fbo);
}

blit_fbo_to_screen :: proc(fbo : Fbo_id, src_x, src_y, src_width, src_height, dst_x, dst_y, dst_width, dst_height : i32, use_linear_interpolation := false) {
	
	interpolation : gl.GLenum = .NEAREST;

	if use_linear_interpolation {
		interpolation = .LINEAR;
	}

	if cpu_state.gl_version >= .opengl_4_5 {
		gl.BlitNamedFramebuffer(auto_cast fbo, 0, src_x, src_y, src_width, src_height, dst_x, dst_y, dst_width, dst_height, .COLOR_BUFFER_BIT, interpolation);
	}
	else {
		gl.BindFramebuffer(.READ_FRAMEBUFFER, auto_cast fbo);
		gl.BindFramebuffer(.DRAW_FRAMEBUFFER, 0);
		gl.BlitFramebuffer(src_x, src_y, src_width, src_height, dst_x, dst_y, dst_width, dst_height, .COLOR_BUFFER_BIT, interpolation); //TODO options for .COLOR_BUFFER_BIT, .NEAREST
		gl.BindFramebuffer(.READ_FRAMEBUFFER, 0);
	}
}

//////////////////////////////////////////// Private functions ////////////////////////////////////////////

@(require_results)
get_shader_attributes :: proc(program_id : Shader_program_id, alloc := context.allocator, loc := #caller_location) -> (res : map[string]Attribute_info) {

	context.allocator = alloc;

	count : i32;
	max_length : i32;
	gl.GetProgramiv(auto_cast program_id, .ACTIVE_ATTRIBUTES, &count);
	gl.GetProgramiv(auto_cast program_id, .ACTIVE_ATTRIBUTE_MAX_LENGTH, &max_length);

	res = make(map[string]Attribute_info);

	for i in 0..<count {
		
		name_buf : []u8 = make([]u8, max_length + 2);
		defer delete(name_buf);

		name_len : i32;
		size : i32; // size of the variable
		
		shader_type : Attribute_type;

		gl.GetActiveAttrib(auto_cast program_id, auto_cast i, auto_cast len(name_buf), &name_len, &size, auto_cast &shader_type, cast([^]u8)raw_data(name_buf));
		assert(size == 1, "size is not 1, I have missunderstood something...");

		name : string = strings.clone_from_bytes(name_buf[:name_len]);
		fmt.assertf(utils.is_enum_valid(shader_type), "uniform %s is not a supported type. OpenGL type : %v", name, cast(gl.GLenum)shader_type, loc = loc);
		res[name] = Attribute_info{location = get_attribute_location(program_id, name), attribute_type = auto_cast shader_type};
	}

	return;
}

@(require_results)
get_shader_uniforms :: proc(program_id : Shader_program_id, alloc := context.allocator, loc := #caller_location) -> (res : map[string]Uniform_info) {

	context.allocator = alloc;

	count : i32;
	max_length : i32;
	gl.GetProgramiv(auto_cast program_id, .ACTIVE_UNIFORMS, &count);
	gl.GetProgramiv(auto_cast program_id, .ACTIVE_UNIFORM_MAX_LENGTH, &max_length);

	res = make(map[string]Uniform_info);
	
	for i in 0..<count {

		name_buf : []u8 = make([]u8, max_length + 2);
		defer delete(name_buf);

		name_len : i32;
		size : i32; // size of the variable
		shader_type : Uniform_type;

		gl.GetActiveUniform(auto_cast program_id, auto_cast i, auto_cast len(name_buf), &name_len, &size, auto_cast &shader_type, cast([^]u8)raw_data(name_buf));

		name : string = strings.clone_from_bytes(name_buf[:name_len]);

		if strings.has_suffix(name, "[0]") {
			assert(size != 1, "It is an array with size 1?, so it is an array?");
			
			//strip [0]
			delete(name);
			name = strings.clone_from_bytes(name_buf[:name_len-3]);
		}
		else {
			assert(size == 1, "It is not an array?, but the size is not 1?");
		}

		fmt.assertf(utils.is_enum_valid(shader_type), "uniform %s is not a supported type. OpenGL type : %v", name, cast(gl.GLenum)shader_type, loc = loc);
		res[name] = Uniform_info{location = get_uniform_location(program_id, name), uniform_type = auto_cast shader_type, array_size = size};
	}

	return;
}

@(require_results)
get_attribute_location :: proc(shader_id : Shader_program_id, attrib_name : string) -> Attribute_id {
	return auto_cast gl.GetAttribLocation(auto_cast shader_id, fmt.ctprintf(attrib_name));
}

@(require_results)
get_uniform_location :: proc(shader_id : Shader_program_id, uniform_name : string) -> Uniform_id {
	return auto_cast gl.GetUniformLocation(auto_cast shader_id, fmt.ctprintf(uniform_name));
}